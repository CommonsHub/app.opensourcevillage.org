/**
 * Client-side NOSTR relay utilities
 *
 * Handles direct WebSocket communication with relays from the browser.
 * Used for operations that require the user's secret key (signing).
 */

import { finalizeEvent, getPublicKey, type EventTemplate } from 'nostr-tools';

const DEFAULT_RELAYS = ['wss://relay.damus.io', 'wss://nos.lol'];

function getRelayUrls(): string[] {
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem('osv_relay_urls');
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed) && parsed.length > 0) {
          return parsed;
        }
      } catch {
        // Fall through to defaults
      }
    }
  }
  return DEFAULT_RELAYS;
}
const CONNECTION_TIMEOUT = 10_000;
const RESPONSE_TIMEOUT = 15_000;

interface RedeemResult {
  success: boolean;
  error?: string;
}

interface InviteCodeResult {
  success: boolean;
  inviteCode?: string;
  error?: string;
}

/**
 * Redeem an invitation code by sending a kind 28934 event to the relay
 *
 * @param inviteCode - The 192-char hex invitation code
 * @param secretKey - The user's secret key for signing
 */
export async function redeemInviteCode(
  inviteCode: string,
  secretKey: Uint8Array
): Promise<RedeemResult> {
  const relayUrl = getRelayUrls()[0];

  return new Promise((resolve) => {
    let ws: WebSocket | null = null;
    let resolved = false;

    const cleanup = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    };

    const finish = (result: RedeemResult) => {
      if (resolved) return;
      resolved = true;
      cleanup();
      resolve(result);
    };

    const timeout = setTimeout(() => {
      finish({ success: false, error: 'Connection timeout' });
    }, RESPONSE_TIMEOUT);

    try {
      ws = new WebSocket(relayUrl);

      ws.onopen = () => {
        console.log('[NostrRelayClient] Connected to relay:', relayUrl);

        // Create kind 28934 join request event
        const template: EventTemplate = {
          kind: 28934,
          created_at: Math.floor(Date.now() / 1000),
          tags: [['claim', inviteCode]],
          content: '',
        };

        const event = finalizeEvent(template, secretKey);
        console.log('[NostrRelayClient] Sending join request:', event.id);

        ws!.send(JSON.stringify(['EVENT', event]));
      };

      ws.onmessage = (msg) => {
        try {
          const data = JSON.parse(msg.data);
          if (!Array.isArray(data) || data.length < 2) return;

          const [type, ...rest] = data;

          if (type === 'OK') {
            const [eventId, accepted, message] = rest;
            clearTimeout(timeout);

            if (accepted) {
              console.log('[NostrRelayClient] Join request accepted');
              finish({ success: true });
            } else {
              console.log('[NostrRelayClient] Join request rejected:', message);
              finish({ success: false, error: message || 'Invitation code rejected' });
            }
          }

          if (type === 'NOTICE') {
            console.log('[NostrRelayClient] Relay notice:', rest[0]);
          }
        } catch (err) {
          // Ignore parse errors
        }
      };

      ws.onerror = (err) => {
        console.error('[NostrRelayClient] WebSocket error:', err);
        clearTimeout(timeout);
        finish({ success: false, error: 'Connection error' });
      };

      ws.onclose = () => {
        clearTimeout(timeout);
        if (!resolved) {
          finish({ success: false, error: 'Connection closed unexpectedly' });
        }
      };

    } catch (err) {
      clearTimeout(timeout);
      finish({
        success: false,
        error: err instanceof Error ? err.message : 'Failed to connect',
      });
    }
  });
}

/**
 * Request an invitation code from the relay (kind 28935)
 *
 * The user must be authenticated with the relay to receive an invite code.
 * The code is generated by the relay and returned in the event's claim tag.
 *
 * @param secretKey - The user's secret key for authentication
 */
export async function requestInviteCode(secretKey: Uint8Array): Promise<InviteCodeResult> {
  const relayUrl = getRelayUrls()[0];
  const pubkeyHex = getPublicKey(secretKey);

  return new Promise((resolve) => {
    let ws: WebSocket | null = null;
    let resolved = false;
    let authChallenge: string | null = null;

    const cleanup = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    };

    const finish = (result: InviteCodeResult) => {
      if (resolved) return;
      resolved = true;
      cleanup();
      resolve(result);
    };

    const timeout = setTimeout(() => {
      finish({ success: false, error: 'Request timeout' });
    }, RESPONSE_TIMEOUT);

    const sendAuthResponse = (challenge: string) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      // Create kind 22242 auth event (NIP-42)
      const authTemplate: EventTemplate = {
        kind: 22242,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['challenge', challenge],
          ['relay', relayUrl],
        ],
        content: '',
      };

      const authEvent = finalizeEvent(authTemplate, secretKey);
      console.log('[NostrRelayClient] Sending auth response');
      ws.send(JSON.stringify(['AUTH', authEvent]));
    };

    const requestInvite = () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      const subId = `invite_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      console.log('[NostrRelayClient] Requesting invite code, subId:', subId);
      ws.send(JSON.stringify(['REQ', subId, { kinds: [28935], limit: 1 }]));
    };

    try {
      ws = new WebSocket(relayUrl);

      ws.onopen = () => {
        console.log('[NostrRelayClient] Connected to relay for invite request');
        // Try requesting invite - if auth is required, we'll handle it
        requestInvite();
      };

      ws.onmessage = (msg) => {
        try {
          const data = JSON.parse(msg.data);
          if (!Array.isArray(data) || data.length < 2) return;

          const [type, ...rest] = data;

          // Handle AUTH challenge
          if (type === 'AUTH' && typeof rest[0] === 'string') {
            authChallenge = rest[0];
            console.log('[NostrRelayClient] Received auth challenge');
            sendAuthResponse(authChallenge);
            return;
          }

          // Handle OK response to auth
          if (type === 'OK') {
            const [eventId, accepted, message] = rest;
            if (accepted && authChallenge) {
              console.log('[NostrRelayClient] Auth accepted, requesting invite');
              // After successful auth, request invite again
              setTimeout(requestInvite, 100);
            }
            return;
          }

          // Handle EVENT response with invite code
          if (type === 'EVENT') {
            const event = rest[1] as { kind?: number; tags?: string[][] };
            if (event?.kind === 28935) {
              const claimTag = event.tags?.find((t) => t[0] === 'claim');
              if (claimTag?.[1]) {
                clearTimeout(timeout);
                console.log('[NostrRelayClient] Received invite code');
                finish({ success: true, inviteCode: claimTag[1] });
                return;
              }
            }
          }

          // Handle EOSE (end of stored events) - no invite available
          if (type === 'EOSE') {
            // Wait a bit in case the relay generates one
            setTimeout(() => {
              if (!resolved) {
                finish({ success: false, error: 'No invite code available' });
              }
            }, 2000);
          }

          // Handle CLOSED - subscription closed (might need auth)
          if (type === 'CLOSED') {
            const reason = rest[1] || '';
            if (reason.includes('auth-required') && authChallenge) {
              // Already sent auth, wait for result
              return;
            }
            if (reason.includes('auth-required')) {
              // Wait for auth challenge
              console.log('[NostrRelayClient] Auth required, waiting for challenge');
              return;
            }
            clearTimeout(timeout);
            finish({ success: false, error: reason || 'Request rejected' });
          }

          // Handle NOTICE
          if (type === 'NOTICE') {
            console.log('[NostrRelayClient] Relay notice:', rest[0]);
          }

        } catch (err) {
          // Ignore parse errors
        }
      };

      ws.onerror = (err) => {
        console.error('[NostrRelayClient] WebSocket error:', err);
        clearTimeout(timeout);
        finish({ success: false, error: 'Connection error' });
      };

      ws.onclose = () => {
        clearTimeout(timeout);
        if (!resolved) {
          finish({ success: false, error: 'Connection closed' });
        }
      };

    } catch (err) {
      clearTimeout(timeout);
      finish({
        success: false,
        error: err instanceof Error ? err.message : 'Failed to connect',
      });
    }
  });
}

/**
 * Get stored invite code from localStorage, or request a new one
 */
export async function getOrRequestInviteCode(secretKey: Uint8Array): Promise<InviteCodeResult> {
  // Check localStorage first
  const stored = localStorage.getItem('osv_invite_code');
  if (stored && /^[0-9a-f]{192}$/i.test(stored)) {
    return { success: true, inviteCode: stored };
  }

  // Request from relay
  const result = await requestInviteCode(secretKey);

  if (result.success && result.inviteCode) {
    localStorage.setItem('osv_invite_code', result.inviteCode);
  }

  return result;
}

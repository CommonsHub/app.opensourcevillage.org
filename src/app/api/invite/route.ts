/**
 * API endpoint for generating invitation codes
 * POST /api/invite
 * Body: { npub } - the inviter's npub
 *
 * The invitation code is generated by requesting a kind 28935 event from the relay.
 * The code format is: inviterPubkey (64 hex) + signature (128 hex) = 192 chars
 */

import { NextRequest, NextResponse } from 'next/server';
import { nip19, getPublicKey, finalizeEvent, type EventTemplate } from 'nostr-tools';
import WebSocket from 'ws';
import settings from '../../../../settings.json';
import { getProfileByNpub } from '@/lib/storage';

const RELAY_URL = settings.nostrRelays?.[0] || 'ws://localhost:3334';

// For local testing without a real relay, we can generate a simple invite code
// based on the user's pubkey. In production, this should use the relay.
function generateSimpleInviteCode(pubkeyHex: string, secretKey: Uint8Array): string {
  // Create a simple signature-like code for testing
  // In production, this would come from the relay's kind 28935 response
  const timestamp = Math.floor(Date.now() / 1000).toString(16).padStart(8, '0');
  const filler = '0'.repeat(120 - timestamp.length);
  return pubkeyHex + timestamp + filler;
}

interface InviteRequest {
  npub: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: InviteRequest = await request.json();
    const { npub } = body;

    if (!npub || !npub.startsWith('npub1')) {
      return NextResponse.json(
        { success: false, error: 'Invalid npub' },
        { status: 400 }
      );
    }

    // Check if user exists and hasn't exceeded invite limit
    const profile = await getProfileByNpub(npub);
    if (!profile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      );
    }

    const MAX_INVITES = 4;
    const currentInvitees = profile.profile.invitees || [];
    const remainingInvites = MAX_INVITES - currentInvitees.length;

    if (remainingInvites <= 0) {
      return NextResponse.json(
        {
          success: false,
          error: 'You have reached your invite limit',
          invitees: currentInvitees,
          remainingInvites: 0,
        },
        { status: 400 }
      );
    }

    // Decode npub to get pubkey
    const { data: pubkeyHex } = nip19.decode(npub);

    // Try to get invite code from relay
    let inviteCode: string | null = null;

    try {
      inviteCode = await requestInviteCodeFromRelay(pubkeyHex as string);
    } catch (err) {
      console.warn('[Invite API] Failed to get invite from relay, using simple code:', err);
      // For development/testing, generate a simple code
      // In production, this should fail if the relay is unavailable
      if (process.env.NODE_ENV === 'development') {
        inviteCode = generateSimpleInviteCode(pubkeyHex as string, new Uint8Array(32));
      }
    }

    if (!inviteCode) {
      return NextResponse.json(
        { success: false, error: 'Failed to generate invitation code' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      inviteCode,
      invitees: currentInvitees,
      remainingInvites,
    });

  } catch (error) {
    console.error('[Invite API] Error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * Request an invitation code from the NOSTR relay (kind 28935)
 */
async function requestInviteCodeFromRelay(pubkeyHex: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(RELAY_URL, { handshakeTimeout: 10_000 });
    const timeout = setTimeout(() => {
      ws.close();
      reject(new Error('Relay connection timeout'));
    }, 15_000);

    ws.on('open', () => {
      // Request kind 28935 (invite code)
      const subId = `invite_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      ws.send(JSON.stringify(['REQ', subId, { kinds: [28935], authors: [pubkeyHex], limit: 1 }]));
    });

    ws.on('message', (raw: Buffer) => {
      try {
        const msg = JSON.parse(raw.toString());
        if (!Array.isArray(msg) || msg.length < 2) return;

        const [type, ...rest] = msg;

        if (type === 'EVENT') {
          const event = rest[1] as { kind?: number; tags?: string[][] };
          if (event?.kind === 28935) {
            const claimTag = event.tags?.find((t) => t[0] === 'claim');
            if (claimTag?.[1]) {
              clearTimeout(timeout);
              ws.close();
              resolve(claimTag[1]);
              return;
            }
          }
        }

        if (type === 'EOSE') {
          // No invite code found, relay doesn't support this or user not authorized
          clearTimeout(timeout);
          ws.close();
          reject(new Error('No invite code available from relay'));
        }

        if (type === 'CLOSED') {
          const reason = rest[1] || 'Unknown reason';
          clearTimeout(timeout);
          ws.close();
          reject(new Error(`Relay closed request: ${reason}`));
        }
      } catch (err) {
        // Ignore parse errors
      }
    });

    ws.on('error', (err: Error) => {
      clearTimeout(timeout);
      reject(err);
    });

    ws.on('close', () => {
      clearTimeout(timeout);
    });
  });
}

/**
 * GET /api/invite?npub=xxx
 * Check invite status for a user
 */
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const npub = searchParams.get('npub');

  if (!npub || !npub.startsWith('npub1')) {
    return NextResponse.json(
      { success: false, error: 'Invalid npub' },
      { status: 400 }
    );
  }

  try {
    const profile = await getProfileByNpub(npub);
    if (!profile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      );
    }

    const MAX_INVITES = 4;
    const currentInvitees = profile.profile.invitees || [];
    const remainingInvites = MAX_INVITES - currentInvitees.length;

    return NextResponse.json({
      success: true,
      invitees: currentInvitees,
      remainingInvites,
      canInvite: remainingInvites > 0,
    });

  } catch (error) {
    console.error('[Invite API] Error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}
